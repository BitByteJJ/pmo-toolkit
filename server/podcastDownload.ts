// podcastDownload.ts
// POST /api/podcast-download
// Accepts an array of base64 MP3 segments (already generated by /api/podcast),
// concatenates them into a single MP3 buffer, and returns it as a downloadable file.
// MP3 frames are self-synchronising so simple buffer concatenation produces a valid file.

import type { Request, Response } from 'express';

interface DownloadRequest {
  segments: Array<{ audioContent: string; speaker: string; line: string }>;
  title: string;
}

export async function handlePodcastDownload(req: Request, res: Response): Promise<void> {
  try {
    const body = (req as any)._parsedBody ?? (req as any).body ?? {};
    const { segments, title } = body as DownloadRequest;

    if (!Array.isArray(segments) || segments.length === 0) {
      res.status(400).json({ error: 'No segments provided' });
      return;
    }

    // Decode each base64 segment and concatenate into one buffer
    const buffers: Buffer[] = segments.map(seg => {
      if (!seg.audioContent) return Buffer.alloc(0);
      return Buffer.from(seg.audioContent, 'base64');
    });

    const combined = Buffer.concat(buffers);

    // Sanitise the filename
    const safeName = (title ?? 'pmo-podcast')
      .replace(/[^a-z0-9\s-]/gi, '')
      .replace(/\s+/g, '-')
      .toLowerCase()
      .slice(0, 80);

    const filename = `${safeName}-pmo-podcast.mp3`;

    res.setHeader('Content-Type', 'audio/mpeg');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.setHeader('Content-Length', combined.length);
    res.status(200).end(combined);

    console.log(`[PodcastDownload] Served ${(combined.length / 1024).toFixed(0)} KB â€” "${filename}"`);
  } catch (err) {
    console.error('[PodcastDownload] Error:', err);
    res.status(500).json({ error: 'Failed to generate download', details: String(err) });
  }
}
